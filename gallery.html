<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Reflekt Gallery | Archive</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; user-select: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: center; align-items: center; background: rgba(0, 0, 0, 0.95); transition: opacity 0.5s; z-index: 100; }
        #title-container { text-align: center; margin-bottom: 40px; }
        #welcome-title { font-size: 40px; letter-spacing: 10px; font-weight: bold; color: #fff; text-transform: uppercase; animation: glitch 3s infinite; margin-bottom: 15px; text-shadow: 0 0 20px rgba(255, 255, 255, 0.8); }
        #welcome-subtitle { font-size: 14px; color: #888; letter-spacing: 3px; }
        #start-prompt { font-size: 14px; color: #fff; padding: 12px 24px; border: 1px solid #444; background: #000; animation: pulse 2s infinite; cursor: pointer; pointer-events: auto; }
        #hud-container { position: absolute; bottom: 20px; left: 20px; z-index: 50; display: none; }
        .hud-box { background: rgba(0, 0, 0, 0.6); border: 1px solid #333; padding: 15px; color: #ccc; font-size: 14px; }
        .key { color: #fff; font-weight: bold; }
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
        @keyframes glitch { 0% { opacity: 1; } 95% { opacity: 1; } 96% { opacity: 0.8; transform: translateX(2px); } 97% { opacity: 1; transform: translateX(0); } 100% { opacity: 1; } }
        .hidden { opacity: 0; pointer-events: none; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="ui-layer">
        <div id="title-container">
            <div id="welcome-title">REFLEKT GALLERY</div>
            <div id="welcome-subtitle">IMMERSIVE ARCHIVE SPACE</div>
        </div>
        <div id="start-prompt">[ CLICK TO ENTER ]</div>
    </div>

    <div id="hud-container">
        <div class="hud-box">
            <div><span class="key">W A S D</span> TO WALK</div>
            <div style="margin-top:5px;"><span class="key">MOUSE</span> TO LOOK</div>
        </div>
    </div>

    <script>
        // Array of your session captures
        const IMAGE_FILES = [
            'residue1.png', 'residue2.png', 'residue3.png', 
            'residue4.png', 'residue5.png', 'residue6.png',
            'residue7.png', 'residue8.png', 'residue9.png',
            'residue10.png', 'residue11.png'
        ];
        const MOUSE_SENSITIVITY = 0.0008; 
        const MOVE_SPEED = 8.0; 
        const CAMERA_HEIGHT = 5.5; 

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000); 
        scene.fog = new THREE.Fog(0x000000, 5, 45);   

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);

        const pitchObject = new THREE.Object3D();
        pitchObject.add(camera);
        const yawObject = new THREE.Object3D();
        yawObject.position.y = CAMERA_HEIGHT;
        yawObject.add(pitchObject);
        scene.add(yawObject);

        // --- IMPROVED LIGHTING (Increased by 10%) ---
        scene.add(new THREE.AmbientLight(0xffffff, 0.11)); 
        
        const playerLight = new THREE.PointLight(0xffffff, 0.88, 16.5);
        yawObject.add(playerLight);

        const ceilLight1 = new THREE.PointLight(0x4444ff, 0.55, 44);
        ceilLight1.position.set(10, 20, 0);
        scene.add(ceilLight1);

        const ceilLight2 = new THREE.PointLight(0xff4444, 0.33, 44);
        ceilLight2.position.set(-10, 20, 0);
        scene.add(ceilLight2);

        // UI Logic
        const uiLayer = document.getElementById('ui-layer');
        const hudContainer = document.getElementById('hud-container');
        const startPrompt = document.getElementById('start-prompt');
        let isLocked = false;

        startPrompt.addEventListener('click', () => document.body.requestPointerLock());
        document.addEventListener('pointerlockchange', () => {
            isLocked = (document.pointerLockElement === document.body);
            uiLayer.classList.toggle('hidden', isLocked);
            hudContainer.style.display = isLocked ? 'block' : 'none';
        });

        document.addEventListener('mousemove', (e) => {
            if (!isLocked) return;
            yawObject.rotation.y -= e.movementX * MOUSE_SENSITIVITY;
            pitchObject.rotation.x -= e.movementY * MOUSE_SENSITIVITY;
            pitchObject.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitchObject.rotation.x));
        });

        const keys = { w: false, a: false, s: false, d: false };
        const onKey = (val) => (e) => { 
            const k = e.key.toLowerCase();
            if (['w','s','a','d'].includes(k)) keys[k] = val;
            if (e.code === 'ArrowUp') keys.w = val; if (e.code === 'ArrowDown') keys.s = val;
        };
        document.addEventListener('keydown', onKey(true));
        document.addEventListener('keyup', onKey(false));

        // WORLD
        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(100, 100), 
            new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.1, metalness: 0.5 })
        );
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        const wallMat = new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 0.8 });
        const wallGeo = new THREE.BoxGeometry(60, 25, 1);
        
        const walls = [
            { pos: [0, 12.5, -20], rot: [0, 0, 0] },
            { pos: [-20, 12.5, 0], rot: [0, Math.PI/2, 0] },
            { pos: [20, 12.5, 0], rot: [0, -Math.PI/2, 0] }
        ];
        walls.forEach(w => {
            const m = new THREE.Mesh(wallGeo, wallMat);
            m.position.set(...w.pos);
            m.rotation.set(...w.rot);
            scene.add(m);
        });

        // --- STRIKING HEADER (Reduced by 10% from previous huge size) ---
        const textCanvas = document.createElement('canvas');
        const ctx = textCanvas.getContext('2d');
        textCanvas.width = 2048;
        textCanvas.height = 512;
        ctx.fillStyle = "white";
        ctx.font = "900 160px 'Courier New', monospace";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.letterSpacing = "15px";
        ctx.shadowColor = "rgba(255, 255, 255, 1)";
        ctx.shadowBlur = 40;
        ctx.fillText("REFLEKT GALLERY", textCanvas.width / 2, textCanvas.height / 2);
        ctx.shadowBlur = 10;
        ctx.fillText("REFLEKT GALLERY", textCanvas.width / 2, textCanvas.height / 2);

        const textTex = new THREE.CanvasTexture(textCanvas);
        textTex.anisotropy = renderer.capabilities.getMaxAnisotropy();
        const textMat = new THREE.MeshBasicMaterial({ 
            map: textTex, 
            transparent: true, 
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide
        });
        
        // Width 45, Height 11.25 (10% smaller than previous 50x12.5)
        const textPlane = new THREE.Mesh(new THREE.PlaneGeometry(45, 11.25), textMat);
        textPlane.position.set(0, 14, -19.4); 
        scene.add(textPlane);

        // --- CYCLING GALLERY SYSTEM ---
        const textureLoader = new THREE.TextureLoader();
        const frames = [];
        
        // Create a shuffled copy of images for cycling
        let imageQueue = [...IMAGE_FILES];
        // Shuffle the queue
        for (let i = imageQueue.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [imageQueue[i], imageQueue[j]] = [imageQueue[j], imageQueue[i]];
        }
        let queueIndex = 0;
        
        // Track currently displayed images
        const displayedImages = new Set();

        function getSafePosition(sideX, currentFrameId) {
            let attempts = 0;
            let pos = { y: 0, z: 0 };
            let isOverlapping;
            
            do {
                isOverlapping = false;
                pos.y = 4 + Math.random() * 8;
                pos.z = (Math.random() - 0.5) * 32;
                
                for (let other of frames) {
                    if (other.uuid === currentFrameId) continue;
                    if (other.userData.baseX === sideX) {
                        const dist = Math.sqrt(Math.pow(pos.y - other.position.y, 2) + Math.pow(pos.z - other.position.z, 2));
                        if (dist < 10) { 
                            isOverlapping = true;
                            break;
                        }
                    }
                }
                attempts++;
            } while (isOverlapping && attempts < 20);
            
            return pos;
        }

        function getNextImageFromQueue() {
            // Get next image from queue
            const img = imageQueue[queueIndex];
            queueIndex++;
            
            // If we've gone through all images, reshuffle and start over
            if (queueIndex >= imageQueue.length) {
                queueIndex = 0;
                // Reshuffle to keep variety
                for (let i = imageQueue.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [imageQueue[i], imageQueue[j]] = [imageQueue[j], imageQueue[i]];
                }
            }
            
            return img;
        }

        function spawnFrame(sideX, rotationY) {
            const group = new THREE.Group();
            group.rotation.y = rotationY;
            // Random spawn delay between 0-15 seconds for elegant staggered appearance
            const spawnDelay = Math.random() * 15;
            group.userData = { 
                targetOpacity: 0, 
                currentOpacity: 0, 
                nextChangeTime: spawnDelay, 
                baseX: sideX, 
                fadeState: 'out',
                currentImage: null
            };
            
            // Create frame border (edges only, no diagonals)
            const borderMat = new THREE.LineBasicMaterial({ color: 0x666666, linewidth: 2 });
            const borderGeom = new THREE.BufferGeometry();
            const w = 12, h = 8; // half-width and half-height
            const borderVertices = new Float32Array([
                // Top edge
                -w, h, 0,  w, h, 0,
                // Right edge
                w, h, 0,  w, -h, 0,
                // Bottom edge
                w, -h, 0,  -w, -h, 0,
                // Left edge
                -w, -h, 0,  -w, h, 0
            ]);
            borderGeom.setAttribute('position', new THREE.BufferAttribute(borderVertices, 3));
            const border = new THREE.LineSegments(borderGeom, borderMat);
            group.add(border);

            const placeholder = new THREE.Mesh(
                new THREE.PlaneGeometry(24, 16),
                new THREE.MeshBasicMaterial({ color: 0x111111, transparent: true, opacity: 0 })
            );
            placeholder.position.z = 0.01;
            group.add(placeholder);
            group.userData.placeholder = placeholder;

            const safe = getSafePosition(sideX, group.uuid);
            group.position.set(sideX, safe.y, safe.z);

            scene.add(group);
            frames.push(group);
        }

        // Create 4 frames total (2 per wall)
        for(let i=0; i<2; i++) { 
            spawnFrame(-19.4, Math.PI/2); 
            spawnFrame(19.4, -Math.PI/2); 
        }

        const clock = new THREE.Clock();
        const moveDir = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.1);
            const time = clock.getElapsedTime();

            moveDir.set(0,0,0);
            if (keys.w) moveDir.z -= 1; if (keys.s) moveDir.z += 1;
            if (keys.a) moveDir.x -= 1; if (keys.d) moveDir.x += 1;
            if (moveDir.length() > 0) {
                moveDir.normalize().multiplyScalar(MOVE_SPEED * delta);
                yawObject.translateX(moveDir.x); yawObject.translateZ(moveDir.z);
            }

            frames.forEach(frame => {
                const d = frame.userData;
                if (time > d.nextChangeTime) {
                    if (d.fadeState === 'in') {
                        // Start fading out
                        d.fadeState = 'out';
                        d.targetOpacity = 0.0;
                        // Longer visible duration (8-15 seconds)
                        d.nextChangeTime = time + 8 + Math.random() * 7;
                    } else {
                        // Fade in with NEXT image from queue at NEW position
                        
                        // Remove old image from displayed set
                        if (d.currentImage) {
                            displayedImages.delete(d.currentImage);
                        }
                        
                        // Get next image from cycling queue
                        const nextImage = getNextImageFromQueue();
                        
                        // Clean up old mesh if it exists
                        if (d.mesh) {
                            d.mesh.parent.remove(d.mesh);
                            d.mesh.geometry.dispose();
                            if (d.mesh.material.map) d.mesh.material.map.dispose();
                            d.mesh.material.dispose();
                        }
                        
                        // Load the next image
                        textureLoader.load(nextImage, (tex) => {
                            const imgMat = new THREE.MeshBasicMaterial({ 
                                map: tex, transparent: true, opacity: 0, side: THREE.DoubleSide, 
                                blending: THREE.AdditiveBlending, depthWrite: false 
                            });
                            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(24, 16), imgMat);
                            mesh.position.z = 0.03; 
                            frame.add(mesh);
                            d.mesh = mesh;
                        });
                        
                        // Start fading in with new image at NEW POSITION
                        d.fadeState = 'in';
                        d.targetOpacity = 0.5 + Math.random() * 0.4;
                        d.currentImage = nextImage;
                        displayedImages.add(nextImage);
                        
                        // Get new random position on the wall
                        const safe = getSafePosition(d.baseX, frame.uuid);
                        frame.position.set(d.baseX, safe.y, safe.z);
                        
                        // Longer fade out duration (10-18 seconds)
                        d.nextChangeTime = time + 10 + Math.random() * 8;
                    }
                }
                // Even slower fade transition
                d.currentOpacity += (d.targetOpacity - d.currentOpacity) * 0.002;
                if (d.mesh) d.mesh.material.opacity = d.currentOpacity;
                if (d.placeholder) d.placeholder.material.opacity = d.currentOpacity * 0.2;
            });

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>